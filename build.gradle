plugins {
    id 'java-library'

    alias(libs.plugins.champeau.jmh).apply(false)
    alias(libs.plugins.license).apply(false)
    alias(libs.plugins.scalastyle).apply(false)
    alias(libs.plugins.shadowjar).apply(false)

    alias(libs.plugins.versionCatalogUpdate)
}

apply from: 'build.params.gradle'
apply plugin: 'base'

allprojects {
    group = 'org.opencypher'
    version = ver.self

    // Gradle version-catalog-update has to be able to resolve the dependencies.
    repositories {
        mavenCentral()
        mavenLocal()
    }
}

apply from: 'build.licenses.gradle'

subprojects {
    apply plugin: 'scala'
    apply plugin: 'java-library'

    dependencies {
        implementation libs.scala.library

        // Seems we need to lock these down, otherwise we get runtime errors on reflection
        implementation libs.scala.lang.compiler
        implementation libs.scala.lang.reflect

        implementation libs.log4j.api
        implementation libs.scala.log4j.api

        testImplementation libs.log4j.core
        testImplementation libs.testing.scala.scalatest
        testImplementation libs.testing.scala.scalacheck
        testImplementation libs.testing.junit
        testImplementation libs.testing.mockito.all
        testRuntimeOnly libs.testing.junit.platform.runner
    }

    test {
        maxHeapSize = "2g"
        maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
        useJUnit()

        // JVM args required by spark (see org.apache.spark.launcher.JavaModuleOptions)
        jvmArgs(
                '-XX:+IgnoreUnrecognizedVMOptions',
                '--add-exports=java.base/sun.nio.ch=ALL-UNNAMED',
                '--add-opens=java.base/java.lang.invoke=ALL-UNNAMED',
                '--add-opens=java.base/java.lang=ALL-UNNAMED',
                '--add-opens=java.base/java.lang.invoke=ALL-UNNAMED',
                '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED',
                '--add-opens=java.base/java.io=ALL-UNNAMED',
                '--add-opens=java.base/java.net=ALL-UNNAMED',
                '--add-opens=java.base/java.nio=ALL-UNNAMED',
                '--add-opens=java.base/java.util=ALL-UNNAMED',
                '--add-opens=java.base/java.util.concurrent=ALL-UNNAMED',
                '--add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED',
                '--add-opens=java.base/jdk.internal.ref=ALL-UNNAMED',
                '--add-opens=java.base/sun.nio.ch=ALL-UNNAMED',
                '--add-opens=java.base/sun.nio.cs=ALL-UNNAMED',
                '--add-opens=java.base/sun.security.action=ALL-UNNAMED',
                '--add-opens=java.base/sun.util.calendar=ALL-UNNAMED',
                '--add-opens=java.security.jgss/sun.security.krb5=ALL-UNNAMED',
                '-Djdk.reflect.useDirectMethodHandle=false'
        )

        def testTempDir = layout.buildDirectory.get().dir("tmp/test").asFile
        testTempDir.mkdirs()
        systemProperty 'java.io.tmpdir', testTempDir.absolutePath
    }

    ext.scalacParameters = [
            '-unchecked',
            '-deprecation',
            '-feature',
            '-Xfatal-warnings',
            '-Xfuture',
            '-Ypartial-unification',
            '-Ywarn-adapted-args'
    ]

    tasks.withType(ScalaCompile) {
        options.encoding = 'UTF-8'
        scalaCompileOptions.additionalParameters = scalacParameters
    }

    tasks.withType(ScalaDoc) {
        scalaDocOptions.additionalParameters = scalacParameters
    }

    task sourceJar(type: Jar) {
        archiveClassifier = 'sources'
        from(sourceSets.main.allSource)
    }

    task docJar(type: Jar) {
        dependsOn tasks.scaladoc
        archiveClassifier = 'javadoc'
        from(tasks.scaladoc.destinationDir)
    }

    task testJar(type: Jar) {
        archiveClassifier = 'tests'
        from(sourceSets.test.output)
    }

    tasks.withType(Jar) {
        from(tasks.generateLicensesFiles) {
            into("META-INF/")
        }
    }

    task licenseFile {
        outputs.file(project.parent.file('LICENSE.txt'))
    }

    task dependencySearch(type: DependencyInsightReportTask) {
        description = 'Searches all projects for a dependency'
        group = 'help'
    }

    task runApp {
        dependsOn tasks.classes
        group = 'run'
        description = 'Run a custom Scala app (use -PmainClass=com.my.package.App)'
        doLast {
            javaexec {
                classpath = sourceSets.main.runtimeClasspath
                main = project.getProperty("mainClass")
            }
        }
    }

    // copied from https://stackoverflow.com/a/38058671/568723
    task depSize  {
        description = 'Lists all dependencies sorted by their size'
        doLast {
            final formatStr = "%,10.2f"
            final conf = configurations.default
            final size = conf.collect { it.length() / (1024 * 1024) }.sum()
            final out = new StringBuffer()
            out << 'Total dependencies size:'.padRight(45)
            out << "${String.format(formatStr, size)} Mb\n\n"
            conf.sort { -it.length() }
                    .each {
                        out << "${it.name}".padRight(45)
                        out << "${String.format(formatStr, (it.length() / 1024))} kb\n"
                    }
            println(out)
        }
    }
}

apply from: 'build.publishing.gradle'
apply from: 'build.style.gradle'
apply from: 'build.version.catalog.update.gradle'
